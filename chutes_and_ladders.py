# -*- coding: utf-8 -*-
"""chutes_and_ladders.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ButoSLASbwxPFWl2CJF74g3UZNWhlMFW
"""

from random import Random
import matplotlib.pyplot as plt
import numpy as np


CHUTES_LADDERS = {1:38, 4:14, 9:31, 16:6, 21:42, 28:84, 36:44,
                  47:26, 49:11, 51:67, 56:53, 62:19, 64:60,
                  71:91, 80:100, 87:24, 93:73, 95:75, 98:78}

# globalize cl_mat
cl_mat = np.zeros((101, 101))
ind = [CHUTES_LADDERS.get(i, i) for i in range(101)]
cl_mat[ind, range(101)] = 1


def simulate_cl_game(rseed=None, max_roll=6):
    # simulate full Chutes and Ladders game, return the number of turns to complete

    rand = Random(rseed)
    position = 0
    turns = 0
    while position < 100:
        turns += 1
        roll = rand.randint(1, max_roll)
        
        # if the roll moves player past 100, don't move
        if position + roll > 100:
            continue
            
        # else, move to square according to  roll
        position += roll
        
        # travel through chute/ladder
        position = CHUTES_LADDERS.get(position, position)
    return turns

num_of_sim = 100
  
sim_games = [simulate_cl_game() for i in range(num_of_sim)]

plt.hist(sim_games, bins=range(1000), density=True)
plt.xlabel('Number of Turns')
plt.ylabel('Probability of Completing Game')
plt.title(f'Simulating {num_of_sim} Games of Chutes & Ladders')

# finding the expected value using simulation

exp_value = 0
num_of_games = 100000

for i in range(num_of_games):
  turns = simulate_cl_game()
  exp_value += turns

exp_value = exp_value/num_of_games

print(exp_value)

def cl_markov_matrix(max_roll=6):
    # create a game transition matrix

    # create the basic transition matrix (G):
    mat = np.zeros((101, 101))
    for i in range(101):
        mat[i + 1:i + 1 + max_roll, i] = 1. / max_roll
        
    # if rolls past 100, don't change state and add probabilities to original position
    mat[range(101), range(101)] += 1 - mat.sum(0)

    # create chutes and ladders transition matrix (C)
    cl_mat = np.zeros((101, 101))
    ind = [CHUTES_LADDERS.get(i, i) for i in range(101)]
    cl_mat[ind, range(101)] = 1

    return cl_mat @ mat


def cl_probability(n):
    # calculate state vector after n turns
    mat = cl_markov_matrix()
    v_0 = [1, *np.zeros(100)]
    return np.linalg.matrix_power(mat, n) @ v_0

probs = [cl_probability(i)[-1] for i in range(200)]

# prob graph
plt.hist(sim_games, bins=range(200), align='mid', density=True, alpha=0.5);
plt.plot(np.arange(1, 200), np.diff(probs), color='black')
plt.title('Chutes and Ladders Probability of Completion')
plt.xlabel('Number of Turns')
plt.ylabel('Probability of Completion')
plt.show()

# cumulative prob graph
plt.hist(sim_games, bins=range(200), density=True, align='mid', cumulative=True, alpha=0.5);
plt.plot(np.arange(200), probs, color='black');
plt.title('Chutes and Ladders Cumulative Probability of Completion')
plt.xlabel('Number of Turns')
plt.ylabel('Cumulative Probability of Completion');
plt.show()

# finding expected value/mean

exp_value = 0

for i in range(199):
  if i != 0:
    exp_value += i * (np.diff(probs)[i-1])

print(exp_value)

# finding variance and standard deviation

import math

e_xsquared = 0

for i in range(199):
  if i != 0:
    e_xsquared += i**2 * (np.diff(probs)[i-1])

variance = e_xsquared - exp_value**2
print(variance)

std = math.sqrt(variance)
print(std)

# finding skewness

from scipy.stats import skew

skewness = skew(np.diff(probs), axis = 0, bias = True)

print(skewness)

# finding r-squared value

from sklearn.metrics import r2_score

binned_sim = np.histogram(sim_games, range(200), density=True)
r2 = r2_score(binned_sim[0], np.diff(probs))
print(r2)

# finding probability that p1 wins
# p(p1 finishes in n turns) * p(p2 finishes in n turns or more)

total_p = 0

for i in range(199):
  p = np.diff(probs)[i] * (1 - probs[i])
  total_p += p

print(total_p)

indict_c = np.zeros(101)
indict_l = np.zeros(101)
chutes = []
ladders = []

for i in range(len(CHUTES_LADDERS)):
  if CHUTES_LADDERS.get(list(CHUTES_LADDERS)[i]) > list(CHUTES_LADDERS)[i]:
    ladders.append(list(CHUTES_LADDERS)[i])
  else:
    chutes.append(list(CHUTES_LADDERS)[i])

indict_c[chutes] = 1
indict_l[ladders] = 1

probs_c = 0
probs_l = 0

# globalize game matrix without chutes or ladders (G)
mat = np.zeros((101, 101))
for i in range(101):
    mat[i + 1:i + 1 + 6, i] = 1. / 6
mat[range(101), range(101)] += 1 - mat.sum(0)


for i in range(200):
  if i != 0:
    # [i-1] to get position before traveling c or l
    prob_before_cl = mat @ cl_probability(i-1)

    # multiply by indicator matrix, add to expected value
    pc = np.dot(indict_c, prob_before_cl)
    probs_c += pc
    pl = np.dot(indict_l, prob_before_cl)
    probs_l += pl
  
print(probs_l)
print(probs_c)